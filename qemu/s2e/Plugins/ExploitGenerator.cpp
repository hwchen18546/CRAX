#include <s2e/S2E.h>
#include <s2e/S2EExecutor.h>
#include <s2e/Utils.h>
#include <klee/util/ExprUtil.h>
#include "ExploitGenerator.h"

using namespace std;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(ExploitGenerator,
                  "Exploit Vulnerabilities",
                  "Exploit Generator",);

void ExploitGenerator::initialize()
{

void ExploitGenerator::onEipCorrupt(
        S2EExecutionState *state,
        klee::ref<klee::Expr> eipValue)
{
    /* Address of the beginning of an object */
    set<uint64_t> taintedAddressSet;
    /**
     * first:  start address of a consecutive symbolic data
     * second: width of the symbolic data
     */
    map<uint64_t, uint64_t> symbolicArrayMap;

    s2e()->getMessagesStream(state) << "EIP is tainted by "
        << s2e()->getExecutor()->toConstantSilent(*state, eipValue)
        << ", original value is " << eipValue << "\n";

    findTaintedObjects(state, 0x00000000, 0xFFFFFFFF, &taintedAddressSet);
    findSymbolicArray(state, taintedAddressSet, &symbolicArrayMap);
}

void ExploitGenerator::findTaintedObjects(
        S2EExecutionState *state,
        uint64_t minAddress,
        uint64_t maxAddress,
        set<uint64_t> *taintedAddressSet)
{
    uint64_t hostAddress = 0;
    klee::ObjectPair op;

    for (uint64_t i_pageNumber = minAddress; i_pageNumber <= maxAddress;
            i_pageNumber += TARGET_PAGE_SIZE) {

        /* invalid page fault */
        if (likely(state->getPhysicalAddress(i_pageNumber) == (uint64_t) -1)) {
            continue;
        }

        for (uint64_t j_objectStartAddress = i_pageNumber;
                j_objectStartAddress <= i_pageNumber + TARGET_PAGE_SIZE;
                j_objectStartAddress += S2E_RAM_OBJECT_SIZE) {

            hostAddress = state->getHostAddress(j_objectStartAddress);

            if (hostAddress == (uint64_t) -1) {
                continue;
            }

            op = state->addressSpace.findObject(hostAddress);
            if (op.second->isAllConcrete()) {
                continue;
            }

            taintedAddressSet->insert(j_objectStartAddress);
        }
    }
}

void ExploitGenerator::findSymbolicArray(
        S2EExecutionState *state,
        set<uint64_t> const& taintedAddressSet,
        map<uint64_t, uint64_t> *symbolicArrayMap)
{
    klee::ObjectPair op;
    const klee::MemoryObject *mo;
    const klee::ObjectState *os;

    set<uint64_t>::iterator it_objectStartAddress;
    for (it_objectStartAddress = taintedAddressSet.begin();
            it_objectStartAddress != taintedAddressSet.end();
            it_objectStartAddress++) {

        op = state->addressSpace.findObject(
             state->getHostAddress(*it_objectStartAddress));
        mo = op.first;
        os = op.second;

        bool isPreviousByteConstant = true;
        uint64_t startAddress = 0, width = 0;

        uint64_t i_pageOffset = mo->address & ~S2E_RAM_OBJECT_MASK;
        for (; i_pageOffset < mo->size; i_pageOffset++) {

            klee::ref<klee::Expr> byte = os->read8(i_pageOffset);
            if (!isa<klee::ConstantExpr>(byte)) {
                /* Start of a symbolic array */
                if (isPreviousByteConstant) {
                    startAddress = *it_objectStartAddress | i_pageOffset;
                    width = 1;
                }
                else {
                    width++;
                }
                isPreviousByteConstant = false;
            }
            else {
                /* End of a symbolic array */
                if (!isPreviousByteConstant) {
                    s2e()->getMessagesStream(state)
                        << "Found Symbolic Array at " << hexval(startAddress)
                        << ", width " << width << "\n";
                    symbolicArrayMap->insert(make_pair(startAddress, width));
                }
                isPreviousByteConstant = true;
                continue;
            }
        }
    }
}

} // namespace plugins
} // namespace s2e
