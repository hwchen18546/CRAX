#ifndef S2E_PLUGINS_EXPLOIT_H
#define S2E_PLUGINS_EXPLOIT_H

#include <s2e/Plugin.h>
#include <s2e/Plugins/CorePlugin.h>
#include <s2e/S2EExecutionState.h>

using namespace std;

namespace s2e {
namespace plugins {

class ExploitGenerator : public Plugin
{
    S2E_PLUGIN
public:
    ExploitGenerator(S2E *s2e): Plugin(s2e) {}

    void initialize();

private:
    string m_shellCode;

    klee::ref<klee::Expr> m_eipValue;

    time_t m_startTime;
    time_t m_exploreTime;
    time_t m_endTime;

    typedef std::pair<std::string, std::vector<unsigned char> > VarValuePair;
    typedef std::vector<VarValuePair> ConcreteInputs;

    void onEipCorrupt(S2EExecutionState *state,
                      klee::ref<klee::Expr> eipValue);

    void timerStart(S2EExecutionState *state);

    void timerStop(S2EExecutionState *state);

    void findTaintedObjects(S2EExecutionState *state,
                            uint64_t startAddress,
                            uint64_t endAddress,
                            set<uint64_t> *taintedAddressSet);

    void findSymbolicArray(S2EExecutionState *state,
                           set<uint64_t> const& taintedAddressSet,
                           map<uint64_t, uint64_t> *symbolicArrayMap);

    void pruneInputConstraints(S2EExecutionState *state,
                               klee::ExecutionState *exploitState);

    klee::ref<klee::Expr> generateConstraints(S2EExecutionState *state,
                                              uint64_t startAddress,
                                              uint64_t shellCodeAddress,
                                              uint64_t nopAttempt,
                                              uint64_t failedPivot,
                                              uint64_t successPivot);

    void generateRopExploit(S2EExecutionState *state,
                         uint64_t startAddress, uint64_t width);

    void generateExploit(S2EExecutionState *state,
                         uint64_t startAddress, uint64_t width);

    string str2byte(string str);

    inline bool isPivotsOverlapped(uint64_t x, uint64_t y)
    {
        return ((x == y) || (abs((int64_t)(x - y)) == 1));
    }
};

} // namespace plugins
} // namespace s2e

#endif
